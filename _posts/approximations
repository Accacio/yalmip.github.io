To showcase the generality of the [interp1](/command/interp1), let us answer a common question which addresses the problem of solving integer quadratic programs using linear solvers, and to make matters worse, we study indefinite quadratic objectives.

The simple idea we will use is to approximate the quadratic function as a pocewise affine function. Of course, this is not necessarily a good way to solve indefinite integer quadratic programs, but it is a common strategy. Let us assume we want to minimize the indefinite objective \\(x'^TQx - y^TRy\\) over the unit-box intersected with \\(\sum x + \sum y = 1\\).

````matlab
x = sdpvar(3,1);
y = sdpvar(3,1);
Q = randn(3);Q = Q*Q';
R = randn(3);R = R*R';
Model = [-1 <= [x y] <= 1, sum(x) + sum(y) == 1];
````

To begin with, a problem here is that the model is multivariate, but the [interp1](/command/interp1) only acts on univariate data. To handle that, we factorize the quadratic functions so we can write them as sums of univariate functions \\(\sum e_i^2 - \sum f_i^2\\)
````matlab
S = chol(Q);
T = chol(R);
e = sdpvar(3,1);
f = sdpvar(3,1);
Model = [-1 <= [x y] <= 1, sum(x) + sum(y) == 1, e == S*x, f == T*y];
````

Our next step is to introduce a piecewise affine approximation of every quadratic term \\(e_i\\) and \\(f_i\\) using [interp1]((command/interp1). To do this, we have to define the domain on which the functions are approximated, i.e., find lower and upper bounds on the elements in \\(e\\) and \\(f\\). WE can conviently do that using [boundingbox](/command/boundingbox)

````matlab
[~,Le,Ue] = boundingbox(Model,[],e);
[~,Lf,Uf] = boundingbox(Model,[],f);
````

Now, generate a grid over the bounding box and define the piecewise affine approximators

````matlab
E = repmat(Le,1,100) + repmat(linspace(0,1,100),3,1).*repmat(Ue-Le,1,20);
F = repmat(Lf,1,100) + repmat(linspace(0,1,100),3,1).*repmat(Uf-Lf,1,20);

f1 = interp1(E,E.^2,e,'lp');
f2 = interp1(F,F.^2,f,'lp');
````

With the flag **'lp'**, the way the interpolant is implemented depends on data and convexity propagation. An efficient linear programming based graph representation will be used if possible, while a mixed-integer [sos2](/commandsos2) otherwise. In our case, the first term is convex and will thus be implemented cheaply, while the second term requires  [sos2](/commandsos2)

````matlab
optimize(Model,sum(f1)-sum(f2))
````

If we have a convex mixed-integer quadratic programming solver, there is no need to approximate the first convex part of the objective, so we can use a partially quadratic model instead
````matlab
Model = [-1 <= [x y] <= 1, f == T*y];
optimize(Model,x'*Q*x-sum(f2))
````
