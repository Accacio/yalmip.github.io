---
layout: single
category: command
author_profile: false
excerpt: 
title: interp1
tags:
comments: true
date: '2016-09-30'
sidebar:
  nav: "commands"
---

[interp1](/command/interp1) overloads interp1, with additional flag for a creating mixed-integer [sos2](/command/sos2)-based approximation and standard convex epi-graph approximations.

### Syntax

````matlab
y = interp1(xdata,ydata,x,'method')
````

### Example (Nonlinear optimization)

Create a nonlinear function over a grid and find the global minima of a spline interpolated version of the nonlinear function, using the global solver [BMIBNB](/solver/bmibnb).

````matlab
xi = (-5:.1:5);
yi = sin(xi) + cos(xi.^2).*sin(xi).^2

sdpvar x
y = interp1(xi,yi,x,'spline');
optimize([],y,sdpsettings('solver','bmibnb'));
plot(xi,yi);hold on;
xii = (-5:0.001:5);
plot(xii,interp1(xi,yi,xii,'spline'));
plot(xii,sin(xii) + cos(xii.^2).*sin(xii).^2)
plot(value(x),value(y),'k*')
````
Alternatively, we can use a linear approximation (still implemented as a nonlinear function using a [callback framework](/tutorial/nonlinearoperatorscallback))

````matlab
y = interp1(xi,yi,x,'spline');
optimize([],y,sdpsettings('solver','bmibnb'));
plot(xi,yi);hold on;
xii = (-5:0.001:5);
plot(xii,interp1(xi,yi,xii,'linear'));
plot(xii,sin(xii) + cos(xii.^2).*sin(xii).^2)
plot(value(x),value(y),'k*')
````

Of course, in this particular case could have worked with the nonlinear function directly which most likely is more efficient as it is composed of very simple operators.

````matlab
y = sin(x)+cos(x^2)*sin(x)^2
optimize([-5 <= x <= 5],y,sdpsettings('solver','bmibnb'))
plot(value(x),value(y),'r*')
````


### Example (Linear optimization)

With the flag **'milp'** a [sos2](/command/sos2) representation of the piecewise affine function is created, and thus requires a [sos2](/command/sos2)-capable [mixed-integer linear solver](/tag#mixed-integer-linear-programming-solver).

````matlab
y = interp1(xi,yi,x,'milp');
optimize([],y)
````

For problems where the data represents a convex (or concave) function and convexity of the problem can be derived, we can (and should!) use a simple linear epi-graph (hypo-graph) representation. This is obtained with the flag **'graph'**. YALMIP will automatically analyze the data and the problem to check convexity

````matlab
yi = 15*xi.^2 - xi.^3 + 20*xi;
y = interp1(xi,yi,x,'graph');
optimize([],y);
clf;
plot(xii,interp1(xi,yi,xii,'linear'));
hold on
plot(value(x),value(y),'r*')
````

If convexity assumptions fail, an error will be generated. If we want YALMIP to adaptively select between an efficient graph model and a MILP based model, we use the flag **'lp'** instead.


````matlab
yi = 15*xi.^2 - 2*xi.^3 + 20*xi;
y = interp1(xi,yi,x,'lp');
optimize([],y);
clf;
plot(xii,interp1(xi,yi,xii,'linear'));
hold on
plot(value(x),value(y),'r*')
````


### Implementation

In the nonlinear case when the operator is implemented using the [callback framework](/tutorial/nonlinearoperatorscallback), the operator does not compute derivatives, which can lead to slow computations (and in general, computing a single function value is expensive).
